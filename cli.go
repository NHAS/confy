package confy

import (
	"encoding"
	"flag"
	"fmt"
	"log/slog"
	"os"
	"path/filepath"
	"reflect"
	"strconv"
	"strings"
)

type stringSlice struct {
	target *[]string
}

func newStringSlice(target interface{}) *stringSlice {
	t, ok := target.(*[]string)
	if !ok {
		panic("could not cast something that was suppose to be a pointer to a string slice")
	}
	return &stringSlice{
		target: t,
	}
}

func (s *stringSlice) String() string {
	return strings.Join(*s.target, ",")
}

func (s *stringSlice) Set(value string) error {
	*s.target = strings.Split(value, ",")
	return nil
}

type intSlice struct {
	target *[]int
}

func newIntSlice(target interface{}) *intSlice {
	t, ok := target.(*[]int)
	if !ok {
		panic("could not cast something that was suppose to be a pointer to a int slice")
	}
	return &intSlice{
		target: t,
	}
}

func (s *intSlice) String() string {

	var result []string
	for _, i := range *s.target {
		result = append(result, fmt.Sprintf("%d", i))
	}

	return strings.Join(result, ",")
}

func (s *intSlice) Set(value string) error {
	for _, potentialInt := range strings.Split(value, ",") {
		i, err := strconv.Atoi(potentialInt)
		if err != nil {
			return err
		}
		*s.target = append(*s.target, i)
	}
	return nil
}

type boolSlice struct {
	target *[]bool
}

func newBoolSlice(target interface{}) *boolSlice {
	t, ok := target.(*[]bool)
	if !ok {
		panic("could not cast something that was suppose to be a pointer to a bool slice")
	}
	return &boolSlice{
		target: t,
	}
}

func (s *boolSlice) String() string {

	var result []string
	for _, i := range *s.target {
		result = append(result, fmt.Sprintf("%t", i))
	}

	return strings.Join(result, ",")
}

func (s *boolSlice) Set(value string) error {
	for _, potentialBool := range strings.Split(value, ",") {
		*s.target = append(*s.target, potentialBool == "true")
	}
	return nil
}

type TextSlice struct {
	concrete reflect.Type
}

func newGenericSlice(concrete reflect.Type) *TextSlice {

	return &TextSlice{
		concrete: concrete,
	}
}

func (s *TextSlice) String() string {
	return string("empty")
}

func (s *TextSlice) Set(value string) error {
	values := strings.Split(value, ",")
	for _, v := range values {

		n := reflect.New(s.concrete).Interface().(encoding.TextUnmarshaler)

		err := n.UnmarshalText([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to unmarshal item %q: %w", v, err)
		}
	}
	return nil
}

type ciParser[T any] struct {
	o *options
}

func newCliLoader[T any](o *options) *ciParser[T] {
	return &ciParser[T]{
		o: o,
	}
}

func (cp *ciParser[T]) apply(result *T) (err error) {

	CommandLine := flag.NewFlagSet(os.Args[0], flag.ContinueOnError)
	CommandLine.SetOutput(os.Stdout)
	if len(os.Args) <= 1 {
		cp.o.logger.Info("no os arguments supplied, not trying to parse cli")
		// There were no args to parse, so the user must not be using the cli
		return nil
	}

	CommandLine.Bool("confy-help", true, "Print command line flags generated by confy")
	for _, field := range getFields(true, result) {

		willAccess := field.value.CanAddr() && field.value.CanInterface()
		cp.o.logger.Info("got field from config", slog.Any(strings.Join(field.path, "."), field.value.String()), "will_continue_parsing", fmt.Sprintf("%t (addr: %t, intf: %t)", willAccess, field.value.CanAddr(), field.value.CanInterface()))

		if willAccess {

			if field.value.Kind() == reflect.Ptr {
				field.value = field.value.Elem()
			}

			resolvedPath := []string{}
			for i := range field.path {

				currentPath := field.path[i]
				_, ft := getField(result, field.path[:i+1])
				if value, ok := ft.Tag.Lookup(confyTag); ok {
					currentPath = value
				}

				resolvedPath = append(resolvedPath, currentPath)
			}

			flagName := strings.Join(resolvedPath, cp.o.cli.delimiter)

			cp.o.logger.Info("resolved confy path", "resolved_path", flagName, "path", strings.Join(field.path, cp.o.cli.delimiter))

			description, ok := field.tag.Lookup(confyDescriptionTag)
			if !ok {
				cp.o.logger.Info("could not find 'confy_description:' tag will auto generate from type", "tags", field.tag, "path", strings.Join(field.path, cp.o.cli.delimiter))

				typeName := field.value.Kind().String()
				if field.value.Kind() == reflect.Slice {
					typeName = field.value.Type().Elem().Kind().String() + " " + typeName
				} else if field.value.Kind() == reflect.Struct {

					pkg := field.value.Type().PkgPath()
					if pkg != "" {
						pkg = filepath.Base(pkg) + "."
					}
					typeName = pkg + field.value.Type().Name() + " " + typeName
				}
				description = fmt.Sprintf("A %s value, %s (%s)", typeName, strings.Join(field.path, cp.o.cli.delimiter), strings.Join(resolvedPath, cp.o.cli.delimiter))
			}

			cp.o.logger.Info("adding flag", "flag", "-"+flagName, "type", field.value.Kind())

			switch field.value.Kind() {
			case reflect.String:
				CommandLine.StringVar(field.value.Addr().Interface().(*string), flagName, "", description)
			case reflect.Int:
				CommandLine.IntVar(field.value.Addr().Interface().(*int), flagName, 0, description)
			case reflect.Int64:
				CommandLine.Int64Var(field.value.Addr().Interface().(*int64), flagName, 0, description)
			case reflect.Bool:
				CommandLine.BoolVar(field.value.Addr().Interface().(*bool), flagName, false, description)
			case reflect.Float64:
				CommandLine.Float64Var(field.value.Addr().Interface().(*float64), flagName, 0, description)
			case reflect.Slice:
				var parser flag.Value
				sliceContentType := field.value.Type().Elem()
				switch sliceContentType.Kind() {
				case reflect.String:
					parser = newStringSlice(field.value.Addr().Interface())
				case reflect.Int:
					parser = newIntSlice(field.value.Addr().Interface())
				case reflect.Bool:
					parser = newBoolSlice(field.value.Addr().Interface())
				default:

					inter := reflect.TypeOf((*encoding.TextUnmarshaler)(nil)).Elem()
					if !reflect.PointerTo(sliceContentType).Implements(inter) {
						cp.o.logger.Warn("type inside of complex slice did not implement encoding.TextUnmarshaler", "flag", flagName, "path", strings.Join(field.path, cp.o.cli.delimiter))
						continue
					}

					parser = newGenericSlice(sliceContentType)
				}

				CommandLine.Var(parser, flagName, description)
			case reflect.Struct:

				textUnmarshaler, ok := field.value.Addr().Interface().(encoding.TextUnmarshaler)
				if !ok {
					cp.o.logger.Warn("structure implement encoding.TextUnmarshaler", "flag", flagName, "path", strings.Join(field.path, cp.o.cli.delimiter))
					continue
				}

				textMarshaler, ok := field.value.Addr().Interface().(encoding.TextMarshaler)
				if !ok {
					cp.o.logger.Warn("structure implement encoding.TextMarshaler", "flag", flagName, "path", strings.Join(field.path, cp.o.cli.delimiter))
					continue
				}

				CommandLine.TextVar(textUnmarshaler, flagName, textMarshaler, description)
			default:
				cp.o.logger.Warn("unsupported type for cli auto-addition", "type", field.value.Kind().String(), "path", strings.Join(field.path, cp.o.cli.delimiter))
				continue
			}
		}

	}
	err = CommandLine.Parse(os.Args[1:])
	if err != nil {
		return err
	}

	help := false
	CommandLine.Visit(func(f *flag.Flag) {
		if f.Name == "confy-help" {
			cp.o.logger.Info("the help flag -confy-help was set")

			help = true
		}
	})

	if help {
		CommandLine.PrintDefaults()
		return flag.ErrHelp
	}

	return nil
}
